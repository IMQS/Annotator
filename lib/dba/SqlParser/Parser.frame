/*-------------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/

/*----------------------------------------------------------------------
Parser.h Specification
-----------------------------------------------------------------------*/

-->begin

#if !defined(-->prefixCOCO_PARSER_H__)
#define -->prefixCOCO_PARSER_H__

-->headerdef

#include "Scanner.h"

-->namespace_open

namespace imqs
{
namespace dba
{
namespace sqlparser
{

	struct ParserError
	{
		int          Line;
		int          Col;
		std::wstring Error;
	};

	class ParserErrors
	{
	public:
		std::vector<ParserError> Errors;

		ParserErrors();

		void		SynErr(int line, int col, int n);
		void		Error(int line, int col, const wchar_t *s);
		void		Warning(int line, int col, const wchar_t *s);
		void		Warning(const wchar_t *s);
		void		Exception(const wchar_t *s);

	}; // ParserErrors

	class Parser 
	{
	private:
-->constantsheader
		Token *			dummyToken;
		int				errDist;
		int				minErrDist;

		void			SynErr(int n);
		void			Get();
		void			Expect(int n);
		bool			StartOf(int s);
		void			ExpectWeak(int n, int follow);
		bool			WeakSeparator(int n, int syFol, int repFol);
		std::string		ConvertWideToUTF8(const wchar_t* src);
	public:
		Scanner *	scanner;
		ParserErrors  *	errors;

		Token *		t;			// last recognized token
		Token *		la;			// lookahead token

		SqlAST*		rootnode = nullptr;
		ObjectGen*	gen = nullptr;

		-->declarations

		Parser(Scanner *scanner);
		~Parser();
		void		SemErr(const wchar_t* msg);

		-->productionsheader

		void		Parse();
		void 		AddNodes(SqlAST* node, ohash::set<void*>& visited);

	

	}; // end Parser

	-->namespace_close
}
}
}

#endif

-->implementation

/*----------------------------------------------------------------------
Parser.cpp Specification
-----------------------------------------------------------------------*/

-->begin
#include "pch.h"
#include <string>
//#include <windows.h>
//#include <wchar.h>
#include "Parser.h"
#include "Scanner.h"
#include "../../SqlStr.h"

//#if _MSC_VER >= 1400
//#pragma warning(disable: 4996)
//#endif

#ifdef _MSC_VER
static bool StrEqNoCase(const char* a, const char* b) { return _stricmp(a, b) == 0; }
#else
static bool StrEqNoCase(const char* a, const char* b) { return strcasecmp(a, b) == 0; }
#endif

-->namespace_open
namespace imqs
{
namespace dba
{
namespace sqlparser
{

//===========================START CUSTOM CODE============================

AnyType::AnyType()
{
}

AnyType::AnyType(const wchar_t* val)
{
	*this = imqs::strings::utf::ConvertWideToUTF8(std::wstring(val)).c_str();
}

AnyType::AnyType(const char* val)
{
	size_t len = strlen(val);
	if (len >= 2)
	{
		if (val[0] == '0' && val[1] == 'x')
		{
			Kind = Hex;
			StrVal = std::string(val).substr(2);
			return;
		}
		if (val[0] == '\'' && val[len - 1] == '\'')
		{
			Kind = SQuotedString;
			StrVal.resize(len - 2);
			// Unescape any single quote characters. For example: 'superman''s cape'
			size_t j = 0;
			for (size_t i = 1; i < len - 1; i++)
			{
				StrVal[j++] = val[i];
				if (val[i] == '\'')
				{
					// Assume this is a pair. Our lexer should guarantee that.
					i++;
				}
			}
			if (j < StrVal.length())
				StrVal.erase(StrVal.begin() + j);
			return;
		}
		else if (val[0] == '"' && val[len - 1] == '"')
		{
			Kind = DQuotedString;
			StrVal.assign(val + 1, len - 2);
			return;
		}
	}

	// Assume this is a manually built up AST (ie not by a machine-generated parser). In that case,
	// the user knows that he wants a proper string literal, and not a "maybe field, maybe literal" SQLite-ish double quoted string.
	Kind = SQuotedString;
	StrVal = val;
}

AnyType::AnyType(double val) : Kind(Number), NumberVal(val)
{
}

AnyType::AnyType(bool val) : Kind(Bool), BoolVal(val)
{
}

AnyType AnyType::MakeNull()
{
	AnyType a;
	a.Kind = Null;
	return a;
}

void AnyType::Print(SqlStr& out) const
{
	switch (Kind)
	{
	case SQuotedString:
	case DQuotedString:
	{
		out.Squote(StrVal);
		break;
	}
	case Number:
		if (floor(NumberVal) == NumberVal)
			out.Fmt("%.0f", NumberVal);
		else
			out.Fmt("%.12f", NumberVal);
		break;
	case Bool:
		out += BoolVal ? "true" : "false";
		break;
	case Null:
		out += "NULL";
		break;
	case Hex:
		out += StrVal;
		break;
	default:
		IMQS_DIE();
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////

// This list is duplicated in some switch statements inside this file
const char* SqlAST::SVariable = "__VARIABLE";
const char* SqlAST::SValue = "__VALUE";
const char* SqlAST::SCollection = "__COLLECTION";
const char* SqlAST::SCase = "__CASE";
const char* SqlAST::SInsert = "__INSERT";
const char* SqlAST::SFieldList = "__FIELDS";
const char* SqlAST::SValueList = "__VALUES";
const char* SqlAST::SPreparedParam = "__PSPARAM";

SqlAST::SqlAST()
{
}

SqlAST::~SqlAST()
{
	for (auto ast : Params)
		delete ast;
}

SqlAST::SqlAST(const wchar_t* funcName)
{
	FuncName = imqs::strings::utf::ConvertWideToUTF8(std::wstring(funcName));
}

SqlAST::SqlAST(const wchar_t* funcName, const AnyType& val)
{
	FuncName = imqs::strings::utf::ConvertWideToUTF8(std::wstring(funcName));
	Value = val;
}

void SqlAST::Set(const wchar_t* funcName, const AnyType& val)
{
	FuncName = imqs::strings::utf::ConvertWideToUTF8(std::wstring(funcName));
	Value = val;
}

void SqlAST::SetFunction(const char* funcName)
{
	FuncName = funcName;
	Variable = funcName;
	Value = AnyType();
}

void SqlAST::SetOperator(const char* operatorName)
{
	FuncName = operatorName;
	Variable = "";
	Value = AnyType();
}

void SqlAST::SetVariable(const wchar_t* identifier)
{
	SetVariable(imqs::strings::utf::ConvertWideToUTF8(std::wstring(identifier)).c_str());
}

static bool VariableHasSquareBrackets(const char* identifier)
{
	size_t len = strlen(identifier);
	if (len >= 2)
	{
		if (identifier[0] == '[' && identifier[len - 1] == ']')
			return true;
	}
	return false;
}

void SqlAST::AppendFieldToTable(const wchar_t* identifier)
{
	std::string ident = imqs::strings::utf::ConvertWideToUTF8(std::wstring(identifier));

	Variable += ".";

	if (VariableHasSquareBrackets(ident.c_str()))
		Variable.append(ident.c_str() + 1, ident.size() - 2);
	else
		Variable += ident;
}

void SqlAST::SetVariable(const char* identifier)
{
	FuncName = SVariable;
	Value = AnyType();

	if (VariableHasSquareBrackets(identifier))
		Variable.assign(identifier + 1, strlen(identifier) - 2);
	else
		Variable = identifier;
}

void SqlAST::SetValue(const AnyType& value)
{
	FuncName = SValue;
	Variable = "";
	Value = value;
}

void SqlAST::SetPreparedParam(int paramNumBase1)
{
	FuncName = SPreparedParam;
	Value = (double) paramNumBase1;
}

void SqlAST::SetNullValue()
{
	SetValue(AnyType::MakeNull());
}

void SqlAST::PrintParameters(SqlStr& out, size_t startIndex) const
{
	if (startIndex >= Params.size())
		return;
	for (size_t i = startIndex; i < Params.size(); i++)
	{
		Params[i]->Print(out);
		out += ", ";
	}
	out.Chop(2);
}

void SqlAST::Print(SqlStr& out) const
{
	uint32_t printFlags = 0;
	switch (Type())
	{
	case TypeFunction:
		if (out.Dialect->UseThisCall(FuncName.c_str()))
		{
			Params[0]->Print(out);
			out += ".";
			out.Dialect->NativeFunc(*this, out, printFlags);
			out += "(";
			PrintParameters(out, 1);
			out += ")";
			break;
		} else
		{
			out.Dialect->NativeFunc(*this, out, printFlags);
		}
		if (!(printFlags & PrintFlags::PrintExcludeParameters))
		{
			out += "(";
			if (StrEqNoCase(FuncName.c_str(), "CAST") && Params.size() == 2)
			{
				if (Params[0]->IsVariable())
					out.Fmt("%Q", Params[0]->Variable);
				else
					Params[0]->Value.Print(out);
				out.Fmt(" AS %v", Params[1]->Value.StrVal);
			}
			else
			{
				PrintParameters(out);
				if (!!(printFlags & PrintFlags::PrintAdd4326))
					out += ", 4326";
			}
			out += ")";
		}
		break;
	case TypeOperator:
		out += "(";
		if (Params.size() == 1)
		{
			// "exp ISNULL" is an example of an operator expression with only a single parameter - this is postfix unary.
			// "NOT exp" is similar, but is prefix unary.
			if (StrEqNoCase(FuncName.c_str(), "NOT"))
			{
				out.Dialect->NativeFunc(*this, out, printFlags);
				out += " ";
				Params[0]->Print(out);
			}
			else
			{
				Params[0]->Print(out);
				out += " ";
				out.Dialect->NativeFunc(*this, out, printFlags);
			}
		}
		else
		{
			IMQS_ASSERT(Params.size() == 2);
			Params[0]->Print(out);
			out += " ";
			out.Dialect->NativeFunc(*this, out, printFlags);
			out += " ";
			Params[1]->Print(out);
		}
		out += ")";
		break;
	case TypeVariable:
		if (Variable == "*")
		{
			out += "*";
		}
		else
		{
			if (out.Dialect->IsSoftKeyword(Variable.c_str()))
			{
				// This is for things such as CURRENT_DATE in Postgres
				out += Variable;
			}
			else
			{
				out.Identifier(Variable);
			}
		}
		break;
	case TypeValue:
		switch (Value.Kind)
		{
			case AnyType::Hex:
				out.Dialect->NativeHexLiteral(Value.StrVal.c_str(), out);
				break;
			default:
				Value.Print(out);
		}
		break;
	case TypeCollection:
		out += "(";
		PrintParameters(out);
		out += ")";
		break;
	case TypeCase:
		out += "CASE";
		if (!Params[Case_Base]->IsNullValue())
		{
			out += " ";
			Params[Case_Base]->Print(out);
			out += " ";
		}
		out += "\n";
		for (size_t i = 2; i < Params.size(); i += 2)
		{
			out += "WHEN ";
			Params[i]->Print(out);
			out += " THEN ";
			Params[i + 1]->Print(out);
			out += "\n";
		}
		if (!Params[Case_Else]->IsNullValue())
		{
			out += "ELSE ";
			Params[Case_Else]->Print(out);
			out += "\n";
		}
		out += "END\n";
		break;
	case TypeInsert:
		{
			auto into = Params[0];
			auto fields = Params[1];
			auto values = Params[2];
			out += "INSERT INTO ";
			into->Print(out);
			out += " (";
			fields->PrintParameters(out);
			out += ") VALUES ";
			if (values->Params.size() == 0) {
				out += "()";
			} else {
				size_t i = 0;
				while (i < values->Params.size()) {
					out += "(";
					size_t endRow = i + fields->Params.size();
					for (; i < values->Params.size() && i < endRow; i++)
					{
						values->Params[i]->Print(out);
						out += ", ";
					}
					out.Chop(2);
					out += ")";
					out += ", ";
				}
				out.Chop(2);
			}
		}
		break;
	case TypeFieldList:
		PrintParameters(out);
		break;
	case TypeValueList:
		PrintParameters(out);
		break;
	case TypePreparedParam:
		out.Fmt("$%.0f", Value.NumberVal);
		break;
	}
}

void SqlAST::ToJSON(nlohmann::json& out) const {
	if (IsVariable() && Value.Kind == AnyType::DQuotedString)
		out["func"] = "__VALUE_DQUOTE";
	else
		out["func"] = FuncName;

	if (IsVariable()) {
		out["value"] = Variable;
	} else {
		switch (Value.Kind) {
		case AnyType::SQuotedString:
		case AnyType::DQuotedString:
			out["value"] = Value.StrVal;
			break;
		case AnyType::Number:
			out["value"] = Value.NumberVal;
			break;
		case AnyType::Bool:
			out["value"] = Value.BoolVal;
			break;
		case AnyType::Null:
			out["value"] = nlohmann::json();
			break;
		case AnyType::Invalid:
			break;
		case AnyType::Hex:
			out["value"] = Value.StrVal;
			break;
		}
	}
	for (auto p : Params) {
		nlohmann::json tmpval;
		p->ToJSON(tmpval);
		out["params"].emplace_back(std::move(tmpval));
	}
}

SqlAST* SqlAST::Clone() const
{
	SqlAST* c = new SqlAST();
	c->FuncName = FuncName;
	c->Variable = Variable;
	c->Value = Value;
	for (auto p : Params)
		c->Params.push_back(p->Clone());
	/*
	switch (Type())
	{
	case TypeInsert:
		c->NumParams = NumParams;
		break;
	}
	*/
	return c;
}

bool SqlAST::IsFunction() const
{
	return Type() == TypeFunction;
}

bool SqlAST::IsOperator() const
{
	return Type() == TypeOperator;
}

bool SqlAST::IsVariable() const
{
	return Type() == TypeVariable;
}

bool SqlAST::IsCollection() const
{
	return Type() == TypeCollection;
}

bool SqlAST::IsCase() const
{
	return Type() == TypeCase;
}

bool SqlAST::IsValue() const
{
	return Type() == TypeValue;
}

bool SqlAST::IsNumericValue() const
{
	return Type() == TypeValue && Value.IsNumber();
}

bool SqlAST::IsStringValue() const
{
	return Type() == TypeValue && Value.IsString();
}

bool SqlAST::IsHexValue() const
{
	return Type() == TypeValue && Value.IsHex();
}

bool SqlAST::IsBoolValue() const
{
	return Type() == TypeValue && Value.IsBool();
}

bool SqlAST::IsNullValue() const
{
	return Type() == TypeValue && Value.IsNull();
}

bool SqlAST::IsInsert() const
{
	return Type() == TypeInsert;
}

bool SqlAST::IsFieldList() const
{
	return Type() == TypeFieldList;
}

bool SqlAST::IsValueList() const
{
	return Type() == TypeValueList;
}

bool SqlAST::IsPreparedParam() const
{
	return Type() == TypePreparedParam;
}

SqlAST::Types SqlAST::Type() const
{
	// I'm uneasy about this voodoo (ie the FuncName == Variable thing, which implies that this is a function)
	if (FuncName == Variable)
		return TypeFunction;

	switch (hash::crc32(FuncName.c_str(), FuncName.size())) {
	case "__VARIABLE"_crc32: return TypeVariable;
	case "__VALUE"_crc32: return TypeValue;
	case "__COLLECTION"_crc32: return TypeCollection;
	case "__CASE"_crc32: return TypeCase;
	case "__INSERT"_crc32: return TypeInsert;
	case "__FIELDS"_crc32: return TypeFieldList;
	case "__VALUES"_crc32: return TypeValueList;
	case "__PSPARAM"_crc32: return TypePreparedParam;
	}

	return TypeOperator;
}

ObjectGen::ObjectGen()
{
}

SqlAST* ObjectGen::NewAST()
{
	SqlAST* ast = new SqlAST();
	MemAst.push_back(ast);
	return ast;
}

SqlAST* ObjectGen::NewAST(const wchar_t* funcName)
{
	SqlAST* ast = new SqlAST(funcName);
	MemAst.push_back(ast);
	return ast;
}

SqlAST* ObjectGen::NewAST(const wchar_t* funcName, const AnyType& val)
{
	SqlAST* ast = new SqlAST(funcName, val);
	MemAst.push_back(ast);
	return ast;
}

ObjectGen::~ObjectGen()
{
}

void ObjectGen::Clear()
{
	for (auto ast : MemAst)
	{
		if (ast != nullptr) 
		{
			// Prevent node from destroying it's children. We will reach node's children as we iterate through our vector.
			ast->Params.clear();
			delete ast;
		}
	}

	MemAst.clear();
}









	//===========================END CUSTOM CODE============================



void Parser::SynErr(int n)
{
	if (errDist >= minErrDist) errors->SynErr(la->line, la->col, n);
	errDist = 0;
}

void Parser::SemErr(const wchar_t* msg)
{
	if (errDist >= minErrDist) errors->Error(t->line, t->col, msg);
	errDist = 0;
}

void Parser::Get()
{
	for (;;) {
		t = la;
		la = scanner->Scan();
		if (la->kind <= maxT) { ++errDist; break; }
		-->pragmas
			if (dummyToken != t) 
			{
				dummyToken->kind = t->kind;
				dummyToken->pos = t->pos;
				dummyToken->col = t->col;
				dummyToken->line = t->line;
				dummyToken->next = NULL;
				coco_string_delete(dummyToken->val);
				dummyToken->val = coco_string_create(t->val);
				t = dummyToken;
			}
		la = t;
	}
}

void Parser::Expect(int n) 
{
	if (la->kind == n) Get(); else { SynErr(n); }
}

void Parser::ExpectWeak(int n, int follow) 
{
	if (la->kind == n) Get();
	else {
		SynErr(n);
		while (!StartOf(follow)) Get();
	}
}

bool Parser::WeakSeparator(int n, int syFol, int repFol) 
{
	if (la->kind == n) { Get(); return true; }
	else if (StartOf(repFol)) { return false; }
	else {
		SynErr(n);
		while (!(StartOf(syFol) || StartOf(repFol) || StartOf(0))) {
			Get();
		}
		return StartOf(syFol);
	}
}

std::string Parser::ConvertWideToUTF8(const wchar_t* src)
{
	return imqs::strings::utf::ConvertWideToUTF8(std::wstring(src));
}

-->productions


	// If the user declared a method Init and a mehtod Destroy they should
	// be called in the contructur and the destructor respctively.
	//
	// The following templates are used to recognize if the user declared
	// the methods Init and Destroy.

	template<typename T>
struct ParserInitExistsRecognizer 
{
	template<typename U, void (U::*)() = &U::Init>
	struct ExistsIfInitIsDefinedMarker{};

	struct InitIsMissingType 
	{
		char dummy1;
	};

	struct InitExistsType 
	{
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static InitIsMissingType is_here(...);

	// exist only if ExistsIfInitIsDefinedMarker is defined
	template<typename U>
	static InitExistsType is_here(ExistsIfInitIsDefinedMarker<U>*);

	enum { InitExists = (sizeof(is_here<T>(NULL)) == sizeof(InitExistsType)) };
};

template<typename T>
struct ParserDestroyExistsRecognizer 
{
	template<typename U, void (U::*)() = &U::Destroy>
	struct ExistsIfDestroyIsDefinedMarker{};

	struct DestroyIsMissingType 
	{
		char dummy1;
	};

	struct DestroyExistsType 
	{
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static DestroyIsMissingType is_here(...);

	// exist only if ExistsIfDestroyIsDefinedMarker is defined
	template<typename U>
	static DestroyExistsType is_here(ExistsIfDestroyIsDefinedMarker<U>*);

	enum { DestroyExists = (sizeof(is_here<T>(NULL)) == sizeof(DestroyExistsType)) };
};

// The folloing templates are used to call the Init and Destroy methods if they exist.

// Generic case of the ParserInitCaller, gets used if the Init method is missing
template<typename T, bool = ParserInitExistsRecognizer<T>::InitExists>
struct ParserInitCaller 
{
	static void CallInit(T *t) {
		// nothing to do
	}
};

// True case of the ParserInitCaller, gets used if the Init method exists
template<typename T>
struct ParserInitCaller<T, true> 
{
	static void CallInit(T *t) 
	{
		t->Init();
	}
};

// Generic case of the ParserDestroyCaller, gets used if the Destroy method is missing
template<typename T, bool = ParserDestroyExistsRecognizer<T>::DestroyExists>
struct ParserDestroyCaller 
{
	static void CallDestroy(T *t) {
		// nothing to do
	}
};

// True case of the ParserDestroyCaller, gets used if the Destroy method exists
template<typename T>
struct ParserDestroyCaller<T, true> 
{
	static void CallDestroy(T *t) {
		t->Destroy();
	}
};

void Parser::AddNodes(SqlAST* node, ohash::set<void*>& visited)
{
	visited += node;
	for (auto p : node->Params)
	{
		if (p != nullptr)
			AddNodes(p, visited);
	}
}

void Parser::Parse() 
{
	t = NULL;
	la = dummyToken = new Token();
	la->val = coco_string_create(L"Dummy Token");
	Get();

-->parseRoot

	if (rootnode != nullptr)
	{
		ohash::set<void*> usedNodes;
		AddNodes(rootnode, usedNodes);
		for (size_t i = 0; i < gen->MemAst.size(); i++)
		{
			if (!usedNodes.contains(gen->MemAst.at(i)))
			{
				delete gen->MemAst.at(i);
				gen->MemAst.at(i) = nullptr;
			}
		}
	}
}

Parser::Parser(Scanner *scanner) 
{
-->constants
	ParserInitCaller<Parser>::CallInit(this);
	rootnode = nullptr;
	gen = new ObjectGen();
	dummyToken = NULL;
	t = la = NULL;
	minErrDist = 2;
	errDist = minErrDist;
	this->scanner = scanner;
	errors = new ParserErrors();
}

Parser::~Parser() 
{
	ParserDestroyCaller<Parser>::CallDestroy(this);
	delete errors;
	delete dummyToken;
	delete gen;
}

bool Parser::StartOf(int s) 
{
	const bool T = true;
	const bool x = false;

-->initialization

	return set[s][la->kind];
}

ParserErrors::ParserErrors() 
{
}

void ParserErrors::SynErr(int line, int col, int n) 
{
	wchar_t* s;
	switch (n) {
-->errors
	default:
		{
			wchar_t format[20];
			coco_swprintf(format, 20, L"error %d", n);
			s = coco_string_create(format);
		}
		break;
	}
	Errors.push_back({line, col, s});
	coco_string_delete(s);
}

void ParserErrors::Error(int line, int col, const wchar_t *s) 
{
	Errors.push_back({line, col, s});
}

void ParserErrors::Warning(int line, int col, const wchar_t *s) 
{
	//Errors.push_back({line, col, s});
}

void ParserErrors::Warning(const wchar_t *s) 
{
	//Errors.push_back({0, 0, s});
}

void ParserErrors::Exception(const wchar_t* s) 
{
	IMQS_DIE();
	Errors.push_back({0, 0, std::wstring(L"Internal parser error: ") + s});
}

	-->namespace_close
}
}
}
