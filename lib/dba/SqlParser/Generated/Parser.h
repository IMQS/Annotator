/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/


#if !defined(COCO_PARSER_H__)
#define COCO_PARSER_H__

#include <string>
#include <vector>
#include <cstddef>
#include <iostream>
#include <atomic>

//#if _MSC_VER >= 1400
//#pragma warning(disable: 4996) // CRT security
//#endif

namespace imqs
{
namespace dba
{

class SqlStr;

namespace sqlparser
{

class IMQS_DBA_API AnyType
{
public:
	enum Kinds
	{
		Invalid = -1,
		SQuotedString = 0,
		DQuotedString = 1,
		Number = 2,
		Bool = 3,
		Null = 4,
		Hex = 5,
	};
	std::string 	StrVal;				// Quotes are stripped from this value.
	double 			NumberVal = 0;
	Kinds 			Kind = Invalid;
	bool			BoolVal = false;
	
	AnyType();
	AnyType(const char* val);
	AnyType(const wchar_t* val);
	AnyType(double val);
	AnyType(bool val);
	static AnyType MakeNull();

	void 			Print(SqlStr& out) const;
	bool			IsString() const { return Kind == SQuotedString || Kind == DQuotedString; }
	bool			IsNumber() const { return Kind == Number; }
	bool			IsBool() const { return Kind == Bool; }
	bool			IsHex() const { return Kind == Hex; }
	bool			IsNull() const { return Kind == Null; }
};
	
/* Abstract Syntax Tree node.

Special rules:
CASE:
	Param[0] = 'base'. NullValue if there is no base. Use Case_Base. See https://www.sqlite.org/lang_expr.html for an explanation of the 'base' in a case statement
	Param[1] = 'else'. NullValue if there is no else. Use Case_Else.
	Param[2] = 'when' expression of first case block
	Param[3] = 'then' expression of first case block
	Param[4] = 'when' expression of second case block
	Param[5] = 'then' expression of second case block
	etc

INSERT:
	Param[0] = Table
	Param[1] = Fields
		Param[0] = field1
		Param[1] = field2
		...
	Param[2] = Values (can contain multiple rows, tightly packed, for Postgres multi-row insert statement)
		Param[0] = value1
		Param[1] = value2
		...

PreparedParam:
	Value.NumberVal holds the 1-based parameter number.

*/

class IMQS_DBA_API SqlAST
{
public:
	enum Types
	{
		TypeFunction,		// function (eg sum, average, count)
		TypeOperator,		// operator (eg <, >, =)
		TypeVariable,		// column name
		TypeValue,			// number, string, null,
		TypeCollection,		// set eg: (1, 2, 3)
		TypeCase,			// case statement
		TypeInsert,			// INSERT statement
		TypeFieldList,		// field list (eg in INSERT statement)
		TypeValueList,		// value list (eg in INSERT statement VALUES portion)
		TypePreparedParam,	// Parameter to a prepared statement ($1, $2, etc)
	};
	
	enum PrintFlags
	{
		PrintNormal             = 0,
		PrintExcludeParameters  = 1, // When printing, only call NativeFunc.. do not print parameters
		PrintAdd4326            = 2, // For geometry, always add an additional parameter "4326" to the function. This is a hack for the MSSQL driver.
	};

	enum SQLEmitFlags
	{
		SQLEmitAsThis	= 1
	};

	static const char*		SVariable;
	static const char*		SValue;
	static const char*		SCollection;
	static const char*		SCase;
	static const char*		SInsert;
	static const char*		SFieldList;
	static const char*		SValueList;
	static const char*		SPreparedParam;

	std::atomic<int>		RefCount;		// For use in a cache
	std::string 			FuncName;
	std::vector<SqlAST*>	Params;
	std::string 			Variable;
	AnyType 				Value;
	uint32_t				EmitFlags = 0;

	SqlAST();	
	SqlAST(const wchar_t* funcName);
	SqlAST(const wchar_t* funcName, const AnyType& val);
	~SqlAST();
	
	void 				Set(const wchar_t* funcName, const AnyType& val);
	void 				SetFunction(const char* funcName);
	void 				SetOperator(const char* operatorName);
	void 				SetVariable(const wchar_t* identifier);
	void 				SetVariable(const char* identifier);
	void 				SetValue(const AnyType& value);
	void 				SetPreparedParam(int paramNumBase1);
	void 				SetNullValue();
	void 				AppendFieldToTable(const wchar_t* identifier);
	void 				Print(SqlStr& out) const;
	void 				ToJSON(nlohmann::json& out) const;
	SqlAST*				Clone() const;
	bool				IsFunction() const;
	bool				IsOperator() const;
	bool				IsVariable() const;
	bool				IsCollection() const;
	bool				IsCase() const;
	bool				IsValue() const;
	bool				IsNumericValue() const;
	bool				IsStringValue() const;
	bool				IsHexValue() const;
	bool				IsBoolValue() const;
	bool				IsNullValue() const;
	bool				IsInsert() const;
	bool				IsFieldList() const;
	bool				IsValueList() const;
	bool				IsPreparedParam() const;
	Types				Type() const;

	size_t				NumInsertParams() const { return Params[1]->Params.size(); }

	enum
	{
		Case_Base = 0,
		Case_Else = 1,
	};
private:
	void PrintParameters(SqlStr& out, size_t startIndex = 0) const;
};


class ObjectGen 
{
public:
	std::vector<SqlAST*>	MemAst;

	ObjectGen();
	~ObjectGen();

	void					Clear();
	SqlAST* 				NewAST();
	SqlAST* 				NewAST(const wchar_t* funcName);
	SqlAST* 				NewAST(const wchar_t* funcName, const AnyType& val);
};

// namespace close
}
}
}


#include "Scanner.h"



namespace imqs
{
namespace dba
{
namespace sqlparser
{

	struct ParserError
	{
		int          Line;
		int          Col;
		std::wstring Error;
	};

	class ParserErrors
	{
	public:
		std::vector<ParserError> Errors;

		ParserErrors();

		void		SynErr(int line, int col, int n);
		void		Error(int line, int col, const wchar_t *s);
		void		Warning(int line, int col, const wchar_t *s);
		void		Warning(const wchar_t *s);
		void		Exception(const wchar_t *s);

	}; // ParserErrors

	class Parser 
	{
	private:
	enum {
		_EOF=0,
		_floatnumber=1,
		_varname=2,
		_stringl=3,
		_bracketIdent=4,
		_psParam=5,
		_hexlit=6
	};
	int maxT;

		Token *			dummyToken;
		int				errDist;
		int				minErrDist;

		void			SynErr(int n);
		void			Get();
		void			Expect(int n);
		bool			StartOf(int s);
		void			ExpectWeak(int n, int follow);
		bool			WeakSeparator(int n, int syFol, int repFol);
		std::string		ConvertWideToUTF8(const wchar_t* src);
	public:
		Scanner *	scanner;
		ParserErrors  *	errors;

		Token *		t;			// last recognized token
		Token *		la;			// lookahead token

		SqlAST*		rootnode = nullptr;
		ObjectGen*	gen = nullptr;

		

		Parser(Scanner *scanner);
		~Parser();
		void		SemErr(const wchar_t* msg);

			void Statement(SqlAST*& exp);
	void InsertStmt(SqlAST*& exp);
	void Expression(SqlAST*& exp);
	void Ident(SqlAST*& variable_ast);
	void ValuesRow(SqlAST*& values);
	void AndOp(SqlAST*& and_ast);
	void UnaryOpWeak();
	void Case(SqlAST*& case_ast);
	void EqualityOp(SqlAST*& equality_ast);
	void ComparisonOp(SqlAST*& comp_ast);
	void FunctionParams(std::vector<SqlAST*>& params );
	void AddSubOp(SqlAST*& addsub_ast);
	void FactorOp(SqlAST*& factor_ast);
	void ConcatOp(SqlAST*& concat_ast);
	void StringLit(SqlAST*& string_ast);
	void PsParam(SqlAST*& psParam);
	void FloatLit(SqlAST*& float_ast);
	void HexLit(SqlAST*& hex_ast);
	void Cast(SqlAST*& cast_ast);
	void NegatableIdent(SqlAST*& ident_ast);
	void ColumnType(SqlAST*& type_ast);
	void CaseWhen(SqlAST*& case_ast);


		void		Parse();
		void 		AddNodes(SqlAST* node, ohash::set<void*>& visited);

	

	}; // end Parser

	
}
}
}

#endif

