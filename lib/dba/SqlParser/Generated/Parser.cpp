/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/

#include "pch.h"
#include <string>
//#include <windows.h>
//#include <wchar.h>
#include "Parser.h"
#include "Scanner.h"
#include "../../SqlStr.h"

//#if _MSC_VER >= 1400
//#pragma warning(disable: 4996)
//#endif

#ifdef _MSC_VER
static bool StrEqNoCase(const char* a, const char* b) { return _stricmp(a, b) == 0; }
#else
static bool StrEqNoCase(const char* a, const char* b) { return strcasecmp(a, b) == 0; }
#endif


namespace imqs
{
namespace dba
{
namespace sqlparser
{

//===========================START CUSTOM CODE============================

AnyType::AnyType()
{
}

AnyType::AnyType(const wchar_t* val)
{
	*this = imqs::strings::utf::ConvertWideToUTF8(std::wstring(val)).c_str();
}

AnyType::AnyType(const char* val)
{
	size_t len = strlen(val);
	if (len >= 2)
	{
		if (val[0] == '0' && val[1] == 'x')
		{
			Kind = Hex;
			StrVal = std::string(val).substr(2);
			return;
		}
		if (val[0] == '\'' && val[len - 1] == '\'')
		{
			Kind = SQuotedString;
			StrVal.resize(len - 2);
			// Unescape any single quote characters. For example: 'superman''s cape'
			size_t j = 0;
			for (size_t i = 1; i < len - 1; i++)
			{
				StrVal[j++] = val[i];
				if (val[i] == '\'')
				{
					// Assume this is a pair. Our lexer should guarantee that.
					i++;
				}
			}
			if (j < StrVal.length())
				StrVal.erase(StrVal.begin() + j);
			return;
		}
		else if (val[0] == '"' && val[len - 1] == '"')
		{
			Kind = DQuotedString;
			StrVal.assign(val + 1, len - 2);
			return;
		}
	}

	// Assume this is a manually built up AST (ie not by a machine-generated parser). In that case,
	// the user knows that he wants a proper string literal, and not a "maybe field, maybe literal" SQLite-ish double quoted string.
	Kind = SQuotedString;
	StrVal = val;
}

AnyType::AnyType(double val) : Kind(Number), NumberVal(val)
{
}

AnyType::AnyType(bool val) : Kind(Bool), BoolVal(val)
{
}

AnyType AnyType::MakeNull()
{
	AnyType a;
	a.Kind = Null;
	return a;
}

void AnyType::Print(SqlStr& out) const
{
	switch (Kind)
	{
	case SQuotedString:
	case DQuotedString:
	{
		out.Squote(StrVal);
		break;
	}
	case Number:
		if (floor(NumberVal) == NumberVal)
			out.Fmt("%.0f", NumberVal);
		else
			out.Fmt("%.12f", NumberVal);
		break;
	case Bool:
		out += BoolVal ? "true" : "false";
		break;
	case Null:
		out += "NULL";
		break;
	case Hex:
		out += StrVal;
		break;
	default:
		IMQS_DIE();
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////

// This list is duplicated in some switch statements inside this file
const char* SqlAST::SVariable = "__VARIABLE";
const char* SqlAST::SValue = "__VALUE";
const char* SqlAST::SCollection = "__COLLECTION";
const char* SqlAST::SCase = "__CASE";
const char* SqlAST::SInsert = "__INSERT";
const char* SqlAST::SFieldList = "__FIELDS";
const char* SqlAST::SValueList = "__VALUES";
const char* SqlAST::SPreparedParam = "__PSPARAM";

SqlAST::SqlAST()
{
}

SqlAST::~SqlAST()
{
	for (auto ast : Params)
		delete ast;
}

SqlAST::SqlAST(const wchar_t* funcName)
{
	FuncName = imqs::strings::utf::ConvertWideToUTF8(std::wstring(funcName));
}

SqlAST::SqlAST(const wchar_t* funcName, const AnyType& val)
{
	FuncName = imqs::strings::utf::ConvertWideToUTF8(std::wstring(funcName));
	Value = val;
}

void SqlAST::Set(const wchar_t* funcName, const AnyType& val)
{
	FuncName = imqs::strings::utf::ConvertWideToUTF8(std::wstring(funcName));
	Value = val;
}

void SqlAST::SetFunction(const char* funcName)
{
	FuncName = funcName;
	Variable = funcName;
	Value = AnyType();
}

void SqlAST::SetOperator(const char* operatorName)
{
	FuncName = operatorName;
	Variable = "";
	Value = AnyType();
}

void SqlAST::SetVariable(const wchar_t* identifier)
{
	SetVariable(imqs::strings::utf::ConvertWideToUTF8(std::wstring(identifier)).c_str());
}

static bool VariableHasSquareBrackets(const char* identifier)
{
	size_t len = strlen(identifier);
	if (len >= 2)
	{
		if (identifier[0] == '[' && identifier[len - 1] == ']')
			return true;
	}
	return false;
}

void SqlAST::AppendFieldToTable(const wchar_t* identifier)
{
	std::string ident = imqs::strings::utf::ConvertWideToUTF8(std::wstring(identifier));

	Variable += ".";

	if (VariableHasSquareBrackets(ident.c_str()))
		Variable.append(ident.c_str() + 1, ident.size() - 2);
	else
		Variable += ident;
}

void SqlAST::SetVariable(const char* identifier)
{
	FuncName = SVariable;
	Value = AnyType();

	if (VariableHasSquareBrackets(identifier))
		Variable.assign(identifier + 1, strlen(identifier) - 2);
	else
		Variable = identifier;
}

void SqlAST::SetValue(const AnyType& value)
{
	FuncName = SValue;
	Variable = "";
	Value = value;
}

void SqlAST::SetPreparedParam(int paramNumBase1)
{
	FuncName = SPreparedParam;
	Value = (double) paramNumBase1;
}

void SqlAST::SetNullValue()
{
	SetValue(AnyType::MakeNull());
}

void SqlAST::PrintParameters(SqlStr& out, size_t startIndex) const
{
	if (startIndex >= Params.size())
		return;
	for (size_t i = startIndex; i < Params.size(); i++)
	{
		Params[i]->Print(out);
		out += ", ";
	}
	out.Chop(2);
}

void SqlAST::Print(SqlStr& out) const
{
	uint32_t printFlags = 0;
	switch (Type())
	{
	case TypeFunction:
		if (out.Dialect->UseThisCall(FuncName.c_str()))
		{
			Params[0]->Print(out);
			out += ".";
			out.Dialect->NativeFunc(*this, out, printFlags);
			out += "(";
			PrintParameters(out, 1);
			out += ")";
			break;
		} else
		{
			out.Dialect->NativeFunc(*this, out, printFlags);
		}
		if (!(printFlags & PrintFlags::PrintExcludeParameters))
		{
			out += "(";
			if (StrEqNoCase(FuncName.c_str(), "CAST") && Params.size() == 2)
			{
				if (Params[0]->IsVariable())
					out.Fmt("%Q", Params[0]->Variable);
				else
					Params[0]->Value.Print(out);
				out.Fmt(" AS %v", Params[1]->Value.StrVal);
			}
			else
			{
				PrintParameters(out);
				if (!!(printFlags & PrintFlags::PrintAdd4326))
					out += ", 4326";
			}
			out += ")";
		}
		break;
	case TypeOperator:
		out += "(";
		if (Params.size() == 1)
		{
			// "exp ISNULL" is an example of an operator expression with only a single parameter - this is postfix unary.
			// "NOT exp" is similar, but is prefix unary.
			if (StrEqNoCase(FuncName.c_str(), "NOT"))
			{
				out.Dialect->NativeFunc(*this, out, printFlags);
				out += " ";
				Params[0]->Print(out);
			}
			else
			{
				Params[0]->Print(out);
				out += " ";
				out.Dialect->NativeFunc(*this, out, printFlags);
			}
		}
		else
		{
			IMQS_ASSERT(Params.size() == 2);
			Params[0]->Print(out);
			out += " ";
			out.Dialect->NativeFunc(*this, out, printFlags);
			out += " ";
			Params[1]->Print(out);
		}
		out += ")";
		break;
	case TypeVariable:
		if (Variable == "*")
		{
			out += "*";
		}
		else
		{
			if (out.Dialect->IsSoftKeyword(Variable.c_str()))
			{
				// This is for things such as CURRENT_DATE in Postgres
				out += Variable;
			}
			else
			{
				out.Identifier(Variable);
			}
		}
		break;
	case TypeValue:
		switch (Value.Kind)
		{
			case AnyType::Hex:
				out.Dialect->NativeHexLiteral(Value.StrVal.c_str(), out);
				break;
			default:
				Value.Print(out);
		}
		break;
	case TypeCollection:
		out += "(";
		PrintParameters(out);
		out += ")";
		break;
	case TypeCase:
		out += "CASE";
		if (!Params[Case_Base]->IsNullValue())
		{
			out += " ";
			Params[Case_Base]->Print(out);
			out += " ";
		}
		out += "\n";
		for (size_t i = 2; i < Params.size(); i += 2)
		{
			out += "WHEN ";
			Params[i]->Print(out);
			out += " THEN ";
			Params[i + 1]->Print(out);
			out += "\n";
		}
		if (!Params[Case_Else]->IsNullValue())
		{
			out += "ELSE ";
			Params[Case_Else]->Print(out);
			out += "\n";
		}
		out += "END\n";
		break;
	case TypeInsert:
		{
			auto into = Params[0];
			auto fields = Params[1];
			auto values = Params[2];
			out += "INSERT INTO ";
			into->Print(out);
			out += " (";
			fields->PrintParameters(out);
			out += ") VALUES ";
			if (values->Params.size() == 0) {
				out += "()";
			} else {
				size_t i = 0;
				while (i < values->Params.size()) {
					out += "(";
					size_t endRow = i + fields->Params.size();
					for (; i < values->Params.size() && i < endRow; i++)
					{
						values->Params[i]->Print(out);
						out += ", ";
					}
					out.Chop(2);
					out += ")";
					out += ", ";
				}
				out.Chop(2);
			}
		}
		break;
	case TypeFieldList:
		PrintParameters(out);
		break;
	case TypeValueList:
		PrintParameters(out);
		break;
	case TypePreparedParam:
		out.Fmt("$%.0f", Value.NumberVal);
		break;
	}
}

void SqlAST::ToJSON(nlohmann::json& out) const {
	if (IsVariable() && Value.Kind == AnyType::DQuotedString)
		out["func"] = "__VALUE_DQUOTE";
	else
		out["func"] = FuncName;

	if (IsVariable()) {
		out["value"] = Variable;
	} else {
		switch (Value.Kind) {
		case AnyType::SQuotedString:
		case AnyType::DQuotedString:
			out["value"] = Value.StrVal;
			break;
		case AnyType::Number:
			out["value"] = Value.NumberVal;
			break;
		case AnyType::Bool:
			out["value"] = Value.BoolVal;
			break;
		case AnyType::Null:
			out["value"] = nlohmann::json();
			break;
		case AnyType::Invalid:
			break;
		case AnyType::Hex:
			out["value"] = Value.StrVal;
			break;
		}
	}
	for (auto p : Params) {
		nlohmann::json tmpval;
		p->ToJSON(tmpval);
		out["params"].emplace_back(std::move(tmpval));
	}
}

SqlAST* SqlAST::Clone() const
{
	SqlAST* c = new SqlAST();
	c->FuncName = FuncName;
	c->Variable = Variable;
	c->Value = Value;
	for (auto p : Params)
		c->Params.push_back(p->Clone());
	/*
	switch (Type())
	{
	case TypeInsert:
		c->NumParams = NumParams;
		break;
	}
	*/
	return c;
}

bool SqlAST::IsFunction() const
{
	return Type() == TypeFunction;
}

bool SqlAST::IsOperator() const
{
	return Type() == TypeOperator;
}

bool SqlAST::IsVariable() const
{
	return Type() == TypeVariable;
}

bool SqlAST::IsCollection() const
{
	return Type() == TypeCollection;
}

bool SqlAST::IsCase() const
{
	return Type() == TypeCase;
}

bool SqlAST::IsValue() const
{
	return Type() == TypeValue;
}

bool SqlAST::IsNumericValue() const
{
	return Type() == TypeValue && Value.IsNumber();
}

bool SqlAST::IsStringValue() const
{
	return Type() == TypeValue && Value.IsString();
}

bool SqlAST::IsHexValue() const
{
	return Type() == TypeValue && Value.IsHex();
}

bool SqlAST::IsBoolValue() const
{
	return Type() == TypeValue && Value.IsBool();
}

bool SqlAST::IsNullValue() const
{
	return Type() == TypeValue && Value.IsNull();
}

bool SqlAST::IsInsert() const
{
	return Type() == TypeInsert;
}

bool SqlAST::IsFieldList() const
{
	return Type() == TypeFieldList;
}

bool SqlAST::IsValueList() const
{
	return Type() == TypeValueList;
}

bool SqlAST::IsPreparedParam() const
{
	return Type() == TypePreparedParam;
}

SqlAST::Types SqlAST::Type() const
{
	// I'm uneasy about this voodoo (ie the FuncName == Variable thing, which implies that this is a function)
	if (FuncName == Variable)
		return TypeFunction;

	switch (hash::crc32(FuncName.c_str(), FuncName.size())) {
	case "__VARIABLE"_crc32: return TypeVariable;
	case "__VALUE"_crc32: return TypeValue;
	case "__COLLECTION"_crc32: return TypeCollection;
	case "__CASE"_crc32: return TypeCase;
	case "__INSERT"_crc32: return TypeInsert;
	case "__FIELDS"_crc32: return TypeFieldList;
	case "__VALUES"_crc32: return TypeValueList;
	case "__PSPARAM"_crc32: return TypePreparedParam;
	}

	return TypeOperator;
}

ObjectGen::ObjectGen()
{
}

SqlAST* ObjectGen::NewAST()
{
	SqlAST* ast = new SqlAST();
	MemAst.push_back(ast);
	return ast;
}

SqlAST* ObjectGen::NewAST(const wchar_t* funcName)
{
	SqlAST* ast = new SqlAST(funcName);
	MemAst.push_back(ast);
	return ast;
}

SqlAST* ObjectGen::NewAST(const wchar_t* funcName, const AnyType& val)
{
	SqlAST* ast = new SqlAST(funcName, val);
	MemAst.push_back(ast);
	return ast;
}

ObjectGen::~ObjectGen()
{
}

void ObjectGen::Clear()
{
	for (auto ast : MemAst)
	{
		if (ast != nullptr) 
		{
			// Prevent node from destroying it's children. We will reach node's children as we iterate through our vector.
			ast->Params.clear();
			delete ast;
		}
	}

	MemAst.clear();
}









	//===========================END CUSTOM CODE============================



void Parser::SynErr(int n)
{
	if (errDist >= minErrDist) errors->SynErr(la->line, la->col, n);
	errDist = 0;
}

void Parser::SemErr(const wchar_t* msg)
{
	if (errDist >= minErrDist) errors->Error(t->line, t->col, msg);
	errDist = 0;
}

void Parser::Get()
{
	for (;;) {
		t = la;
		la = scanner->Scan();
		if (la->kind <= maxT) { ++errDist; break; }
		
			if (dummyToken != t) 
			{
				dummyToken->kind = t->kind;
				dummyToken->pos = t->pos;
				dummyToken->col = t->col;
				dummyToken->line = t->line;
				dummyToken->next = NULL;
				coco_string_delete(dummyToken->val);
				dummyToken->val = coco_string_create(t->val);
				t = dummyToken;
			}
		la = t;
	}
}

void Parser::Expect(int n) 
{
	if (la->kind == n) Get(); else { SynErr(n); }
}

void Parser::ExpectWeak(int n, int follow) 
{
	if (la->kind == n) Get();
	else {
		SynErr(n);
		while (!StartOf(follow)) Get();
	}
}

bool Parser::WeakSeparator(int n, int syFol, int repFol) 
{
	if (la->kind == n) { Get(); return true; }
	else if (StartOf(repFol)) { return false; }
	else {
		SynErr(n);
		while (!(StartOf(syFol) || StartOf(repFol) || StartOf(0))) {
			Get();
		}
		return StartOf(syFol);
	}
}

std::string Parser::ConvertWideToUTF8(const wchar_t* src)
{
	return imqs::strings::utf::ConvertWideToUTF8(std::wstring(src));
}

void Parser::Statement(SqlAST*& exp) {
		if (la->kind == 7 /* "insert" */) {
			Get();
			Expect(8 /* "into" */);
			InsertStmt(exp);
		} else if (la->kind == 9 /* "dummy_where" */) {
			Get();
			Expression(exp);
		} else SynErr(48);
}

void Parser::InsertStmt(SqlAST*& exp) {
		exp = gen->NewAST(L"__INSERT");
		exp->Params.resize(3);
		SqlAST* fields = gen->NewAST(L"__FIELDS");
		SqlAST* values = gen->NewAST(L"__VALUES");
		exp->Params[1] = fields;
		exp->Params[2] = values; 
		SqlAST* table = gen->NewAST(L""); 
		Ident(table);
		exp->Params[0] = table; 
		Expect(10 /* "(" */);
		SqlAST* field1 = gen->NewAST(); 
		Ident(field1);
		exp->Params[1]->Params.push_back(field1); 
		while (la->kind == 11 /* "," */) {
			Get();
			SqlAST* field = gen->NewAST(); 
			Ident(field);
			exp->Params[1]->Params.push_back(field); 
		}
		Expect(12 /* ")" */);
		Expect(13 /* "values" */);
		ValuesRow(values);
		while (la->kind == 11 /* "," */) {
			Get();
			ValuesRow(values);
		}
}

void Parser::Expression(SqlAST*& exp) {
		exp = gen->NewAST(L"DUMMY_EXP"); 
		if (StartOf(1)) {
			SqlAST* and_ast = nullptr; 
			AndOp(and_ast);
			SqlAST* treebuilder = and_ast; 
			while (la->kind == 14 /* "or" */) {
				Get();
				SqlAST* and_astright = nullptr; 
				AndOp(and_astright);
				SqlAST* tmpnode = gen->NewAST(L"OR"); tmpnode->Params.push_back(treebuilder); tmpnode->Params.push_back(and_astright); treebuilder = tmpnode; 
			}
			exp = treebuilder; 
		} else if (la->kind == 23 /* "not" */) {
			UnaryOpWeak();
			const wchar_t* funcName = t->val; 
			SqlAST* exp_right = nullptr; 
			Expression(exp_right);
			exp = gen->NewAST(funcName); exp->Params.push_back(exp_right); 
		} else if (la->kind == 15 /* "case" */) {
			Get();
			Case(exp);
		} else SynErr(49);
}

void Parser::Ident(SqlAST*& variable_ast) {
		if (la->kind == _varname) {
			Get();
			variable_ast = gen->NewAST(); variable_ast->SetVariable(t->val); 
			if (la->kind == 41 /* "." */) {
				Get();
				Expect(_varname);
				variable_ast->AppendFieldToTable(t->val); 
			}
		} else if (la->kind == _bracketIdent) {
			Get();
			variable_ast = gen->NewAST(); variable_ast->SetVariable(t->val); 
			if (la->kind == 41 /* "." */) {
				Get();
				Expect(_bracketIdent);
				variable_ast->AppendFieldToTable(t->val); 
			}
		} else SynErr(50);
}

void Parser::ValuesRow(SqlAST*& values) {
		Expect(10 /* "(" */);
		SqlAST* val1 = gen->NewAST(); 
		Expression(val1);
		values->Params.push_back(val1); 
		while (la->kind == 11 /* "," */) {
			Get();
			SqlAST* val = gen->NewAST(); 
			Expression(val);
			values->Params.push_back(val); 
		}
		Expect(12 /* ")" */);
}

void Parser::AndOp(SqlAST*& and_ast) {
		SqlAST* equality_ast = nullptr; 
		EqualityOp(equality_ast);
		SqlAST* treebuilder = equality_ast; 
		while (la->kind == 16 /* "and" */) {
			Get();
			SqlAST* equality_astright = nullptr; 
			EqualityOp(equality_astright);
			SqlAST* tmpnode = gen->NewAST(L"AND"); tmpnode->Params.push_back(treebuilder); tmpnode->Params.push_back(equality_astright); treebuilder = tmpnode; 
		}
		and_ast = treebuilder; 
}

void Parser::UnaryOpWeak() {
		Expect(23 /* "not" */);
}

void Parser::Case(SqlAST*& case_ast) {
		case_ast = gen->NewAST(L"__CASE");
		case_ast->Params.push_back(gen->NewAST()); /* base expression */
		case_ast->Params.push_back(gen->NewAST()); /* else expression */
		case_ast->Params[0]->SetNullValue();
		case_ast->Params[1]->SetNullValue(); 
		if (StartOf(2)) {
			Expression((*case_ast).Params[0]);
		}
		CaseWhen(case_ast);
		while (la->kind == 45 /* "when" */) {
			CaseWhen(case_ast);
		}
		if (la->kind == 43 /* "else" */) {
			Get();
			Expression((*case_ast).Params[1]);
		}
		Expect(44 /* "end" */);
}

void Parser::EqualityOp(SqlAST*& equality_ast) {
		SqlAST* comp_ast = nullptr; 
		ComparisonOp(comp_ast);
		equality_ast = comp_ast; SqlAST* treebuilder = comp_ast; 
		if (StartOf(3)) {
			const wchar_t* special = nullptr; 
			while (StartOf(4)) {
				switch (la->kind) {
				case 17 /* "=" */: {
					Get();
					break;
				}
				case 18 /* "==" */: {
					Get();
					break;
				}
				case 19 /* "!=" */: {
					Get();
					break;
				}
				case 20 /* "<>" */: {
					Get();
					break;
				}
				case 21 /* "like" */: {
					Get();
					break;
				}
				case 22 /* "is" */: {
					Get();
					if (la->kind == 23 /* "not" */) {
						Get();
						special = L"IS NOT"; 
					}
					break;
				}
				}
				const wchar_t* funcName = special ? special : t->val; 
				SqlAST* comp_astright = nullptr; 
				ComparisonOp(comp_astright);
				SqlAST* tmpnode = gen->NewAST(funcName); tmpnode->Params.push_back(treebuilder); tmpnode->Params.push_back(comp_astright); treebuilder = tmpnode; 
			}
			equality_ast = treebuilder; 
		} else if (StartOf(5)) {
			if (la->kind == 24 /* "isnull" */) {
				Get();
				equality_ast = gen->NewAST(L"ISNULL"); equality_ast->Params.push_back(treebuilder); 
			} else if (la->kind == 25 /* "notnull" */) {
				Get();
				equality_ast = gen->NewAST(L"NOTNULL"); equality_ast->Params.push_back(treebuilder); 
			} else if (la->kind == 23 /* "not" */) {
				Get();
				SqlAST* tmpnode = gen->NewAST(L"NOT"); 
				if (la->kind == 21 /* "like" */) {
					Get();
					SqlAST* comp_astright = nullptr; 
					ComparisonOp(comp_astright);
					SqlAST* tmpnodelike = gen->NewAST(L"LIKE");  tmpnodelike->Params.push_back(treebuilder);  tmpnodelike->Params.push_back(comp_astright); tmpnode->Params.push_back(tmpnodelike);  
				} else if (la->kind == 26 /* "null" */) {
					Get();
					tmpnode->Params.push_back(treebuilder); tmpnode->Params.push_back(gen->NewAST(L"__VALUE", AnyType::MakeNull()));  
				} else if (la->kind == 27 /* "in" */) {
					Get();
					std::vector<SqlAST*> params; 
					FunctionParams(params);
					tmpnode->SetOperator("NOT IN"); tmpnode->Params.push_back(treebuilder); SqlAST* tmpnodecollection = gen->NewAST(L"__COLLECTION"); tmpnodecollection->Params = params; tmpnode->Params.push_back(tmpnodecollection);
				} else SynErr(51);
				equality_ast = tmpnode; 
			} else {
				Get();
				std::vector<SqlAST*> params; 
				FunctionParams(params);
				SqlAST* tmpnodein = gen->NewAST(L"IN"); tmpnodein->Params.push_back(treebuilder); SqlAST* tmpnodecollection = gen->NewAST(L"__COLLECTION"); tmpnodecollection->Params = params; tmpnodein->Params.push_back(tmpnodecollection); equality_ast = tmpnodein; 
			}
		} else SynErr(52);
}

void Parser::ComparisonOp(SqlAST*& comp_ast) {
		SqlAST* addsub_ast = nullptr; 
		AddSubOp(addsub_ast);
		SqlAST* treebuilder = addsub_ast; 
		while (StartOf(6)) {
			if (la->kind == 28 /* "<" */) {
				Get();
			} else if (la->kind == 29 /* ">" */) {
				Get();
			} else if (la->kind == 30 /* "<=" */) {
				Get();
			} else {
				Get();
			}
			const wchar_t* funcName = t->val; 
			SqlAST* addsub_astright = nullptr; 
			AddSubOp(addsub_astright);
			SqlAST* tmpnode = gen->NewAST(funcName); tmpnode->Params.push_back(treebuilder); tmpnode->Params.push_back(addsub_astright); treebuilder = tmpnode; 
		}
		comp_ast = treebuilder; 
}

void Parser::FunctionParams(std::vector<SqlAST*>& params ) {
		Expect(10 /* "(" */);
		if (la->kind == 34 /* "*" */) {
			Get();
			params.push_back(gen->NewAST(L"__VARIABLE")); params.back()->Variable = "*"; 
		} else if (StartOf(2)) {
			SqlAST* exp = nullptr; 
			Expression(exp);
			params.push_back(exp); 
			while (la->kind == 11 /* "," */) {
				Get();
				SqlAST* exp_multiple = nullptr; 
				Expression(exp_multiple);
				params.push_back(exp_multiple); 
			}
		} else SynErr(53);
		Expect(12 /* ")" */);
}

void Parser::AddSubOp(SqlAST*& addsub_ast) {
		SqlAST* factor_ast = nullptr; 
		FactorOp(factor_ast);
		SqlAST* treebuilder = factor_ast; 
		while (la->kind == 32 /* "+" */ || la->kind == 33 /* "-" */) {
			if (la->kind == 32 /* "+" */) {
				Get();
			} else {
				Get();
			}
			const wchar_t* funcName(t->val); 
			SqlAST* factor_astright = nullptr; 
			FactorOp(factor_astright);
			SqlAST* tmpnode = gen->NewAST(funcName); tmpnode->Params.push_back(treebuilder); tmpnode->Params.push_back(factor_astright); treebuilder = tmpnode; 
		}
		addsub_ast = treebuilder; 
}

void Parser::FactorOp(SqlAST*& factor_ast) {
		SqlAST* concat_ast = nullptr; 
		ConcatOp(concat_ast);
		SqlAST* treebuilder = concat_ast; 
		while (la->kind == 34 /* "*" */ || la->kind == 35 /* "/" */ || la->kind == 36 /* "%" */) {
			if (la->kind == 34 /* "*" */) {
				Get();
			} else if (la->kind == 35 /* "/" */) {
				Get();
			} else {
				Get();
			}
			const wchar_t* funcName = t->val; 
			SqlAST* concat_astright = nullptr; 
			ConcatOp(concat_astright);
			SqlAST* tmpnode = gen->NewAST(funcName); tmpnode->Params.push_back(treebuilder); tmpnode->Params.push_back(concat_astright); treebuilder = tmpnode; 
		}
		factor_ast = treebuilder; 
}

void Parser::ConcatOp(SqlAST*& concat_ast) {
		switch (la->kind) {
		case _stringl: {
			SqlAST* tmpnode = nullptr; 
			StringLit(concat_ast);
			while (la->kind == 37 /* "||" */) {
				tmpnode = gen->NewAST(L"||"); tmpnode->Params.push_back(concat_ast); 
				Get();
				SqlAST* string_astright = nullptr; 
				StringLit(string_astright);
				tmpnode->Params.push_back(string_astright); 
			}
			if (tmpnode != nullptr && tmpnode->Params.size() > 1) concat_ast = tmpnode; 
			break;
		}
		case _psParam: {
			PsParam(concat_ast);
			break;
		}
		case _floatnumber: {
			FloatLit(concat_ast);
			break;
		}
		case 26 /* "null" */: {
			Get();
			concat_ast = gen->NewAST(L"__VALUE", AnyType::MakeNull()); 
			break;
		}
		case _hexlit: {
			HexLit(concat_ast);
			break;
		}
		case _varname: case _bracketIdent: case 33 /* "-" */: case 38 /* "cast" */: case 39 /* "true" */: case 40 /* "false" */: {
			if (la->kind == 38 /* "cast" */) {
				Get();
				Expect(10 /* "(" */);
				Cast(concat_ast);
				Expect(12 /* ")" */);
			} else if (la->kind == 39 /* "true" */) {
				Get();
				concat_ast = gen->NewAST(L"__VALUE", true);
			} else if (la->kind == 40 /* "false" */) {
				Get();
				concat_ast = gen->NewAST(L"__VALUE", false);
			} else {
				NegatableIdent(concat_ast);
				if (la->kind == 10 /* "(" */) {
					FunctionParams((*concat_ast).Params);
					concat_ast->FuncName = concat_ast->Variable; 
				}
			}
			break;
		}
		case 10 /* "(" */: {
			Get();
			Expression(concat_ast);
			Expect(12 /* ")" */);
			break;
		}
		default: SynErr(54); break;
		}
}

void Parser::StringLit(SqlAST*& string_ast) {
		Expect(_stringl);
		string_ast = gen->NewAST(L"__VALUE", t->val); 
}

void Parser::PsParam(SqlAST*& psParam) {
		Expect(_psParam);
		psParam = gen->NewAST(); psParam->SetPreparedParam((int) std::stof(t->val + 1)); 
}

void Parser::FloatLit(SqlAST*& float_ast) {
		Expect(_floatnumber);
		float_ast = gen->NewAST(L"__VALUE", std::stod(t->val)); 
}

void Parser::HexLit(SqlAST*& hex_ast) {
		Expect(_hexlit);
		hex_ast = gen->NewAST(L"__VALUE", t->val); 
}

void Parser::Cast(SqlAST*& cast_ast) {
		cast_ast = gen->NewAST(L"CAST");
		cast_ast->Variable = cast_ast->FuncName;		// Variable = FuncName implies "function"
		cast_ast->Params.push_back(gen->NewAST());
		cast_ast->Params.push_back(gen->NewAST()); 
		Ident((*cast_ast).Params[0]);
		Expect(42 /* "as" */);
		ColumnType((*cast_ast).Params[1]);
}

void Parser::NegatableIdent(SqlAST*& ident_ast) {
		bool isNegative = false; 
		if (la->kind == 33 /* "-" */) {
			Get();
			isNegative = true; 
		}
		Ident(ident_ast);
		if (isNegative) {SqlAST* top = gen->NewAST(); top->SetOperator("-"); top->Params.push_back(ident_ast); ident_ast = top; } 
}

void Parser::ColumnType(SqlAST*& type_ast) {
		std::wstring buf; 
		Expect(_varname);
		buf = t->val; 
		if (la->kind == _varname) {
			Get();
			buf += L" ";
			buf += t->val; 
		}
		type_ast->SetValue(buf.c_str()); 
}

void Parser::CaseWhen(SqlAST*& case_ast) {
		Expect(45 /* "when" */);
		SqlAST* when_ast = nullptr; 
		Expression(when_ast);
		Expect(46 /* "then" */);
		SqlAST* then_ast = nullptr; 
		Expression(then_ast);
		case_ast->Params.push_back(when_ast);
		case_ast->Params.push_back(then_ast); 
}




	// If the user declared a method Init and a mehtod Destroy they should
	// be called in the contructur and the destructor respctively.
	//
	// The following templates are used to recognize if the user declared
	// the methods Init and Destroy.

	template<typename T>
struct ParserInitExistsRecognizer 
{
	template<typename U, void (U::*)() = &U::Init>
	struct ExistsIfInitIsDefinedMarker{};

	struct InitIsMissingType 
	{
		char dummy1;
	};

	struct InitExistsType 
	{
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static InitIsMissingType is_here(...);

	// exist only if ExistsIfInitIsDefinedMarker is defined
	template<typename U>
	static InitExistsType is_here(ExistsIfInitIsDefinedMarker<U>*);

	enum { InitExists = (sizeof(is_here<T>(NULL)) == sizeof(InitExistsType)) };
};

template<typename T>
struct ParserDestroyExistsRecognizer 
{
	template<typename U, void (U::*)() = &U::Destroy>
	struct ExistsIfDestroyIsDefinedMarker{};

	struct DestroyIsMissingType 
	{
		char dummy1;
	};

	struct DestroyExistsType 
	{
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static DestroyIsMissingType is_here(...);

	// exist only if ExistsIfDestroyIsDefinedMarker is defined
	template<typename U>
	static DestroyExistsType is_here(ExistsIfDestroyIsDefinedMarker<U>*);

	enum { DestroyExists = (sizeof(is_here<T>(NULL)) == sizeof(DestroyExistsType)) };
};

// The folloing templates are used to call the Init and Destroy methods if they exist.

// Generic case of the ParserInitCaller, gets used if the Init method is missing
template<typename T, bool = ParserInitExistsRecognizer<T>::InitExists>
struct ParserInitCaller 
{
	static void CallInit(T *t) {
		// nothing to do
	}
};

// True case of the ParserInitCaller, gets used if the Init method exists
template<typename T>
struct ParserInitCaller<T, true> 
{
	static void CallInit(T *t) 
	{
		t->Init();
	}
};

// Generic case of the ParserDestroyCaller, gets used if the Destroy method is missing
template<typename T, bool = ParserDestroyExistsRecognizer<T>::DestroyExists>
struct ParserDestroyCaller 
{
	static void CallDestroy(T *t) {
		// nothing to do
	}
};

// True case of the ParserDestroyCaller, gets used if the Destroy method exists
template<typename T>
struct ParserDestroyCaller<T, true> 
{
	static void CallDestroy(T *t) {
		t->Destroy();
	}
};

void Parser::AddNodes(SqlAST* node, ohash::set<void*>& visited)
{
	visited += node;
	for (auto p : node->Params)
	{
		if (p != nullptr)
			AddNodes(p, visited);
	}
}

void Parser::Parse() 
{
	t = NULL;
	la = dummyToken = new Token();
	la->val = coco_string_create(L"Dummy Token");
	Get();

	Statement(rootnode);


	if (rootnode != nullptr)
	{
		ohash::set<void*> usedNodes;
		AddNodes(rootnode, usedNodes);
		for (size_t i = 0; i < gen->MemAst.size(); i++)
		{
			if (!usedNodes.contains(gen->MemAst.at(i)))
			{
				delete gen->MemAst.at(i);
				gen->MemAst.at(i) = nullptr;
			}
		}
	}
}

Parser::Parser(Scanner *scanner) 
{
	maxT = 47;

	ParserInitCaller<Parser>::CallInit(this);
	rootnode = nullptr;
	gen = new ObjectGen();
	dummyToken = NULL;
	t = la = NULL;
	minErrDist = 2;
	errDist = minErrDist;
	this->scanner = scanner;
	errors = new ParserErrors();
}

Parser::~Parser() 
{
	ParserDestroyCaller<Parser>::CallDestroy(this);
	delete errors;
	delete dummyToken;
	delete gen;
}

bool Parser::StartOf(int s) 
{
	const bool T = true;
	const bool x = false;

	static bool set[7][49] = {
		{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,T,T,T, T,T,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,T,x,x, x,x,T,T, T,x,x,x, x,x,x,x, x},
		{x,T,T,T, T,T,T,x, x,x,T,x, x,x,x,T, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,T,x,x, x,x,T,T, T,x,x,x, x,x,x,x, x},
		{T,x,x,x, x,x,x,x, x,x,x,T, T,x,T,x, T,T,T,T, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,T,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,T, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x}
	};



	return set[s][la->kind];
}

ParserErrors::ParserErrors() 
{
}

void ParserErrors::SynErr(int line, int col, int n) 
{
	wchar_t* s;
	switch (n) {
			case 0: s = coco_string_create(L"EOF expected"); break;
			case 1: s = coco_string_create(L"floatnumber expected"); break;
			case 2: s = coco_string_create(L"varname expected"); break;
			case 3: s = coco_string_create(L"stringl expected"); break;
			case 4: s = coco_string_create(L"bracketIdent expected"); break;
			case 5: s = coco_string_create(L"psParam expected"); break;
			case 6: s = coco_string_create(L"hexlit expected"); break;
			case 7: s = coco_string_create(L"\"insert\" expected"); break;
			case 8: s = coco_string_create(L"\"into\" expected"); break;
			case 9: s = coco_string_create(L"\"dummy_where\" expected"); break;
			case 10: s = coco_string_create(L"\"(\" expected"); break;
			case 11: s = coco_string_create(L"\",\" expected"); break;
			case 12: s = coco_string_create(L"\")\" expected"); break;
			case 13: s = coco_string_create(L"\"values\" expected"); break;
			case 14: s = coco_string_create(L"\"or\" expected"); break;
			case 15: s = coco_string_create(L"\"case\" expected"); break;
			case 16: s = coco_string_create(L"\"and\" expected"); break;
			case 17: s = coco_string_create(L"\"=\" expected"); break;
			case 18: s = coco_string_create(L"\"==\" expected"); break;
			case 19: s = coco_string_create(L"\"!=\" expected"); break;
			case 20: s = coco_string_create(L"\"<>\" expected"); break;
			case 21: s = coco_string_create(L"\"like\" expected"); break;
			case 22: s = coco_string_create(L"\"is\" expected"); break;
			case 23: s = coco_string_create(L"\"not\" expected"); break;
			case 24: s = coco_string_create(L"\"isnull\" expected"); break;
			case 25: s = coco_string_create(L"\"notnull\" expected"); break;
			case 26: s = coco_string_create(L"\"null\" expected"); break;
			case 27: s = coco_string_create(L"\"in\" expected"); break;
			case 28: s = coco_string_create(L"\"<\" expected"); break;
			case 29: s = coco_string_create(L"\">\" expected"); break;
			case 30: s = coco_string_create(L"\"<=\" expected"); break;
			case 31: s = coco_string_create(L"\">=\" expected"); break;
			case 32: s = coco_string_create(L"\"+\" expected"); break;
			case 33: s = coco_string_create(L"\"-\" expected"); break;
			case 34: s = coco_string_create(L"\"*\" expected"); break;
			case 35: s = coco_string_create(L"\"/\" expected"); break;
			case 36: s = coco_string_create(L"\"%\" expected"); break;
			case 37: s = coco_string_create(L"\"||\" expected"); break;
			case 38: s = coco_string_create(L"\"cast\" expected"); break;
			case 39: s = coco_string_create(L"\"true\" expected"); break;
			case 40: s = coco_string_create(L"\"false\" expected"); break;
			case 41: s = coco_string_create(L"\".\" expected"); break;
			case 42: s = coco_string_create(L"\"as\" expected"); break;
			case 43: s = coco_string_create(L"\"else\" expected"); break;
			case 44: s = coco_string_create(L"\"end\" expected"); break;
			case 45: s = coco_string_create(L"\"when\" expected"); break;
			case 46: s = coco_string_create(L"\"then\" expected"); break;
			case 47: s = coco_string_create(L"??? expected"); break;
			case 48: s = coco_string_create(L"invalid Statement"); break;
			case 49: s = coco_string_create(L"invalid Expression"); break;
			case 50: s = coco_string_create(L"invalid Ident"); break;
			case 51: s = coco_string_create(L"invalid EqualityOp"); break;
			case 52: s = coco_string_create(L"invalid EqualityOp"); break;
			case 53: s = coco_string_create(L"invalid FunctionParams"); break;
			case 54: s = coco_string_create(L"invalid ConcatOp"); break;

	default:
		{
			wchar_t format[20];
			coco_swprintf(format, 20, L"error %d", n);
			s = coco_string_create(format);
		}
		break;
	}
	Errors.push_back({line, col, s});
	coco_string_delete(s);
}

void ParserErrors::Error(int line, int col, const wchar_t *s) 
{
	Errors.push_back({line, col, s});
}

void ParserErrors::Warning(int line, int col, const wchar_t *s) 
{
	//Errors.push_back({line, col, s});
}

void ParserErrors::Warning(const wchar_t *s) 
{
	//Errors.push_back({0, 0, s});
}

void ParserErrors::Exception(const wchar_t* s) 
{
	IMQS_DIE();
	Errors.push_back({0, 0, std::wstring(L"Internal parser error: ") + s});
}

	
}
}
}
